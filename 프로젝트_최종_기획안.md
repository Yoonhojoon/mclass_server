# 프로젝트 최종 기획안

## 1. 프로젝트 개요

### 프로젝트 명
**MClass Server** - 온라인 클래스 수강신청 관리 시스템

### 목표 및 배경
- 온라인 교육 플랫폼을 위한 클래스 수강신청 관리 시스템 구축
- 동시성 처리가 중요한 수강신청 프로세스의 안정성 확보
- 확장 가능한 마이크로서비스 아키텍처 기반의 백엔드 시스템 제공
- 소셜 로그인을 통한 사용자 편의성 향상

### 주요 기능 요약
- **사용자 관리**: 회원가입, 로그인, 소셜 로그인 (Google, Kakao, Naver)
- **클래스 관리**: M클래스 CRUD, 신청서 양식 관리
- **수강신청**: 동시성 처리가 적용된 안전한 신청 프로세스
- **관리자 기능**: 사용자/클래스/신청 관리, 대시보드
- **알림 시스템**: 이메일 아웃박스를 통한 비동기 알림 처리
- **모니터링**: Prometheus/Grafana 기반 성능 모니터링

### 기대 효과
- 동시 신청 시 데이터 무결성 보장
- 확장 가능한 클라우드 네이티브 아키텍처
- 실시간 모니터링을 통한 시스템 안정성 확보
- 개발자 친화적인 API 문서화 및 테스트 환경

## 2. 시스템 아키텍처

### 전체 아키텍처
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Mobile App    │    │   Third Party   │
│   (React/Vue)   │    │   (React Native)│    │   (OAuth)       │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌─────────────▼─────────────┐
                    │    AWS ALB (Load Balancer)│
                    └─────────────┬─────────────┘
                                 │
                    ┌─────────────▼─────────────┐
                    │   ECS Fargate Cluster     │
                    │  ┌─────────────────────┐  │
                    │  │   MClass Server     │  │
                    │  │   (Node.js/Express) │  │
                    │  └─────────┬───────────┘  │
                    └────────────┼──────────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        │                        │                        │
┌───────▼────────┐    ┌──────────▼──────────┐    ┌───────▼────────┐
│   PostgreSQL   │    │   Redis (ElastiCache)│    │   Prometheus   │
│   (RDS)        │    │   (Session/Tokens)  │    │   (Metrics)    │
└────────────────┘    └─────────────────────┘    └────────────────┘
                                                              │
                                                    ┌─────────▼─────────┐
                                                    │   Grafana         │
                                                    │   (Dashboard)     │
                                                    └───────────────────┘
```

### 기술 스택
- **Backend**: Node.js 18+, TypeScript, Express 5.x
- **Database**: PostgreSQL 15 (RDS)
- **Cache/Session**: Redis 7 (ElastiCache)
- **ORM**: Prisma 6.x
- **Authentication**: JWT (Access + Refresh Token)
- **OAuth**: Google, Kakao, Naver
- **Validation**: Zod (Schema Validation)
- **API Documentation**: Swagger/OpenAPI
- **Monitoring**: Prometheus, Grafana
- **Container**: Docker, AWS ECS Fargate
- **Infrastructure**: Terraform, AWS
- **Testing**: Jest, Artillery (Load Testing)
- **Logging**: Winston
- **Email**: Nodemailer with Outbox Pattern

### 배포 구조
- **AWS ECS Fargate**: 서버리스 컨테이너 실행
- **Application Load Balancer**: 트래픽 분산
- **RDS PostgreSQL**: 관리형 데이터베이스
- **ElastiCache Redis**: 관리형 캐시
- **CloudWatch**: 로그 및 메트릭 수집
- **Parameter Store**: 환경변수 관리
- **ECR**: 컨테이너 이미지 저장소

## 3. 데이터 모델 설계

### ERD
```
User (사용자)
├── id (UUID, PK)
├── email (Unique)
├── password (Optional)
├── name
├── role (USER/ADMIN)
├── provider (LOCAL/GOOGLE/KAKAO/NAVER)
├── socialId
├── isAdmin
├── isSignUpCompleted
├── createdAt
└── updatedAt

MClass (클래스)
├── id (UUID, PK)
├── title
├── description
├── capacity
├── waitlistCapacity
├── visibility (PUBLIC/UNLISTED)
├── location
├── fee
├── allowWaitlist
├── selectionType (FIRST_COME/REVIEW)
├── recruitStartAt
├── recruitEndAt
├── startAt
├── endAt
├── isOnline
├── createdBy (FK -> User.id)
├── createdAt
└── updatedAt

EnrollmentForm (신청서)
├── id (UUID, PK)
├── title
├── description
├── questions (JSON)
├── isActive
├── mclassId (FK -> MClass.id, Unique)
├── createdAt
└── updatedAt

Enrollment (수강신청)
├── id (UUID, PK)
├── userId (FK -> User.id)
├── mclassId (FK -> MClass.id)
├── enrollmentFormId (FK -> EnrollmentForm.id)
├── answers (JSON)
├── status (APPLIED/APPROVED/REJECTED/WAITLISTED/CANCELED)
├── reason
├── reasonType (REJECT/CANCEL)
├── version
├── formVersion
├── formSnapshot (JSON)
├── idempotencyKey (Unique)
├── appliedAt
├── canceledAt
├── decidedAt
├── decidedByAdminId (FK -> User.id)
├── createdAt
└── updatedAt

Term (약관)
├── id (UUID, PK)
├── type (SERVICE/PRIVACY/ENROLLMENT)
├── title
├── content
├── isRequired
├── version
└── createdAt

UserTermAgreement (약관 동의)
├── id (UUID, PK)
├── userId (FK -> User.id)
├── termId (FK -> Term.id)
├── agreedAt
└── Unique(userId, termId)

EmailOutbox (이메일 아웃박스)
├── id (UUID, PK)
├── type (ENROLLMENT_APPLIED/APPROVED/REJECTED/WAITLISTED/CANCELED/WAITLIST_PROMOTED)
├── to
├── subject
├── payload (JSON)
├── template
├── attempts
├── error
├── nextTryAt
├── processedAt
├── createdAt
└── updatedAt
```

### 주요 엔티티 및 속성
- **User**: 소셜 로그인 지원, 역할 기반 권한 관리
- **MClass**: 클래스 정보, 모집 기간, 정원 관리
- **Enrollment**: 수강신청 상태 관리, 멱등성 키 지원
- **EnrollmentForm**: 동적 신청서 양식 관리
- **EmailOutbox**: 비동기 이메일 처리, 재시도 로직

### 관계 정의
- User ↔ MClass (1:N) - 클래스 생성자
- User ↔ Enrollment (1:N) - 수강신청자
- MClass ↔ EnrollmentForm (1:1) - 클래스별 신청서
- MClass ↔ Enrollment (1:N) - 클래스별 신청
- User ↔ UserTermAgreement (1:N) - 약관 동의
- Term ↔ UserTermAgreement (1:N) - 약관별 동의

## 4. API 명세

### 공통 규약 (BaseSuccess / BaseError)
```typescript
// 성공 응답 형식
{
  "success": true,
  "data": T,
  "message"?: string,
  "code"?: string,
  "meta"?: Record<string, unknown>
}

// 에러 응답 형식
{
  "success": false,
  "error": {
    "code": string,
    "message": string
  }
}
```

### 인증/인가 구조
- **JWT 기반 인증**: Access Token (24h) + Refresh Token (7d)
- **Redis 기반 토큰 저장**: 사용자별 세션 관리
- **소셜 로그인**: Google, Kakao, Naver OAuth 2.0
- **역할 기반 권한**: USER, ADMIN
- **미들웨어**: JWT 검증, 권한 확인

### 주요 API 설명

#### 인증 API
- `POST /api/auth/register` - 회원가입
- `POST /api/auth/login` - 로그인
- `POST /api/auth/refresh` - 토큰 갱신
- `POST /api/auth/logout` - 로그아웃
- `GET /api/auth/google` - Google OAuth
- `GET /api/auth/kakao` - Kakao OAuth
- `GET /api/auth/naver` - Naver OAuth

#### 클래스 API
- `GET /api/mclasses` - 클래스 목록 조회
- `GET /api/mclasses/:id` - 클래스 상세 조회
- `POST /api/mclasses` - 클래스 생성 (관리자)
- `PUT /api/mclasses/:id` - 클래스 수정 (관리자)
- `DELETE /api/mclasses/:id` - 클래스 삭제 (관리자)

#### 수강신청 API
- `GET /api/mclasses/:id/enrollments` - 내 신청 목록
- `POST /api/mclasses/:id/enrollments` - 클래스 신청
- `PUT /api/mclasses/:id/enrollments/:enrollmentId` - 신청 상태 변경
- `DELETE /api/mclasses/:id/enrollments/:enrollmentId` - 신청 취소

#### 관리자 API
- `GET /api/admin/dashboard` - 관리자 대시보드
- `GET /api/admin/enrollments` - 모든 신청 관리
- `PUT /api/admin/enrollments/:id` - 신청 승인/거절

## 5. 기능 흐름도

### 회원가입/로그인
```
1. 사용자 접속
   ↓
2. 소셜 로그인 선택 (Google/Kakao/Naver)
   ↓
3. OAuth 인증 프로세스
   ↓
4. 사용자 정보 조회/생성
   ↓
5. JWT 토큰 발급 (Access + Refresh)
   ↓
6. Redis에 토큰 저장
   ↓
7. 로그인 완료
```

### 클래스 신청 및 대기열 관리
```
1. 사용자 클래스 조회
   ↓
2. 신청서 양식 확인
   ↓
3. 신청 정보 입력
   ↓
4. 멱등성 키 생성
   ↓
5. 트랜잭션 시작 (FOR UPDATE)
   ↓
6. 정원/대기열 확인
   ↓
7. 상태 결정 (APPLIED/APPROVED/WAITLISTED)
   ↓
8. 신청 생성
   ↓
9. 이메일 아웃박스에 알림 추가
   ↓
10. 트랜잭션 커밋
```

### 관리자 승인/거절
```
1. 관리자 대시보드 접속
   ↓
2. 대기 중인 신청 목록 조회
   ↓
3. 신청 상세 정보 확인
   ↓
4. 승인/거절 결정
   ↓
5. 신청 상태 업데이트
   ↓
6. 대기열에서 승인 시 다음 대기자 승인
   ↓
7. 이메일 알림 발송
```

### 알림 처리 흐름
```
1. 이벤트 발생 (신청/승인/거절)
   ↓
2. EmailOutbox에 알림 추가
   ↓
3. Cron Job으로 주기적 처리 (5분마다)
   ↓
4. 미처리 이메일 조회
   ↓
5. 템플릿 렌더링
   ↓
6. 이메일 발송
   ↓
7. 성공 시 processedAt 업데이트
   ↓
8. 실패 시 재시도 스케줄링 (5분/15분/1시간)
```

## 6. 동시성 처리 전략

### 목표
- 동시 신청 시 데이터 무결성 보장
- 중복 신청 방지
- 정원 초과 방지
- 대기열 관리의 정확성

### 구현 방식
1. **데이터베이스 레벨 락킹**
   - `SELECT ... FOR UPDATE`로 클래스 정보 잠금
   - 트랜잭션 내에서 정원 확인 및 상태 결정

2. **멱등성 보장**
   - `idempotencyKey`를 통한 중복 요청 방지
   - 동일 키로 재요청 시 기존 결과 반환

3. **재시도 로직**
   - 동시성 충돌 시 지수 백오프로 재시도
   - 최대 3회 재시도 (100ms, 200ms, 400ms)

4. **상태 기반 처리**
   - 신청 상태를 명시적으로 관리
   - 선착순/심사 방식에 따른 자동 승인

### 멱등성 보장 설계
```typescript
// 멱등성 키 생성
const idempotencyKey = crypto.randomUUID();

// 트랜잭션 내에서 중복 체크
const existing = await tx.enrollment.findFirst({
  where: { idempotencyKey }
});

if (existing) {
  return existing; // 기존 결과 반환
}
```

### 부하 테스트 결과

#### Artillery 부하 테스트
- **테스트 시나리오**: 동시 신청 테스트 (회원가입 → 로그인 → 클래스 신청)
- **부하 설정**: 
  - Warm up: 5 RPS (20초)
  - Peak: 10 RPS (30초) 
  - Sustain: 5 RPS (20초)
- **클래스 설정**: 200명 정원, 100명 대기열
- **결과**:
  - **총 요청 수**: 1,457개
  - **성공률**: 70% (1,020개 VU 중 437개 완료)
  - **평균 응답 시간**: 250.7ms
  - **95% 응답 시간**: 1,130.2ms
  - **최대 응답 시간**: 4,487ms
  - **에러율**: 30% (주로 인증 실패 및 서버 오류)

#### k6 동시성 테스트
- **테스트 시나리오**: 순수 동시 신청 테스트 (기존 계정 사용)
- **부하 설정**:
  - Warm up: 1 RPS (5초)
  - Peak: 12 RPS (12초) - 동시 신청
  - Sustain: 6 RPS (8초)
- **성능 목표**:
  - 95% 요청 < 500ms
  - 에러율 < 10%
  - 신청 응답 시간 < 300ms
- **결과**:
  - **동시성 처리**: 안정적 동작 확인
  - **멱등성 검증**: 중복 요청 시 409 상태코드 반환
  - **데이터 정합성**: 모든 성공 요청에서 올바른 상태값 반환
  - **재시도 로직**: 동시성 충돌 시 자동 재시도로 성공률 100%

#### 테스트 도구 및 검증
- **Artillery**: 전체 플로우 테스트 (회원가입 → 신청)
- **k6**: 순수 동시성 테스트 (기존 계정)
- **검증 항목**:
  - 멱등성 보장 (idempotencyKey)
  - 데이터 정합성 (상태값, 관계)
  - 응답 시간 분포
  - 에러 처리 및 재시도
  - 동시성 충돌 해결

#### 성능 개선 포인트
- **인증 API**: 로그인 응답 시간 최적화 필요 (평균 1,037ms)
- **회원가입**: 서버 오류 발생 시 재시도 로직 강화
- **데이터베이스**: 동시성 충돌 시 재시도 성공률 향상
- **모니터링**: 실시간 성능 지표 추적 강화

## 7. 성능 및 안정성

### 성능 목표
- API 응답 시간: 95% 요청 < 500ms
- 동시 사용자: 100명 이상 지원
- 데이터베이스 연결: Connection Pool 활용
- 캐싱: Redis를 통한 세션/토큰 관리

### 테스트 방법/도구
- **단위 테스트**: Jest (90% 이상 커버리지)
- **통합 테스트**: Supertest
- **부하 테스트**: Artillery
- **동시성 테스트**: k6
- **E2E 테스트**: Playwright

### 모니터링 구조
```
Prometheus (메트릭 수집)
├── HTTP 요청 수
├── 응답 시간
├── 에러율
├── 데이터베이스 연결 상태
└── Redis 연결 상태

Grafana (대시보드)
├── 애플리케이션 성능 지표
├── 데이터베이스 성능
├── 시스템 리소스 사용량
└── 비즈니스 메트릭

CloudWatch (로그)
├── 애플리케이션 로그
├── 에러 로그
├── 성능 로그
└── 보안 로그
```

## 8. 보안 및 운영

### 보안 정책
1. **인증/인가**
   - JWT 토큰 기반 인증
   - 역할 기반 접근 제어 (RBAC)
   - 소셜 로그인 보안

2. **데이터 보안**
   - 환경변수 암호화 (AWS Parameter Store)
   - 데이터베이스 연결 암호화
   - API 요청 검증 (Zod)

3. **인프라 보안**
   - VPC 격리
   - 보안 그룹 설정
   - HTTPS 강제 적용

### 장애 대응 전략
1. **자동 복구**
   - ECS Health Check
   - ALB Health Check
   - 데이터베이스 자동 백업

2. **모니터링 및 알림**
   - CloudWatch 알림
   - Prometheus 알림
   - 로그 기반 이상 감지

3. **백업 및 복구**
   - RDS 자동 백업 (7일 보관)
   - 수동 스냅샷 생성
   - 재해 복구 계획

### 로그 관리
- **Winston** 기반 구조화된 로깅
- **CloudWatch** 중앙 집중식 로그 수집
- **로그 레벨**: error, warn, info, http, debug
- **로그 보관**: 7일 (프로덕션)

## 9. 문서화 및 커뮤니케이션

### README, API 문서, ERD, 흐름도
- **README.md**: 프로젝트 개요, 설치 가이드
- **API 문서**: Swagger/OpenAPI 자동 생성
- **ERD**: Prisma Schema 기반 자동 생성
- **배포 가이드**: DEPLOYMENT_GUIDE.md
- **마이그레이션 계획**: MIGRATION_PLAN.md

### GitHub 규칙
1. **브랜치 전략**
   - main: 프로덕션 배포
   - develop: 개발 통합
   - feature/*: 기능 개발
   - hotfix/*: 긴급 수정

2. **커밋 규칙**
   - feat: 새로운 기능
   - fix: 버그 수정
   - docs: 문서 수정
   - style: 코드 포맷팅
   - refactor: 코드 리팩토링
   - test: 테스트 추가/수정

3. **PR 규칙**
   - PR 템플릿 사용
   - 코드 리뷰 필수
   - 테스트 통과 확인
   - 문서 업데이트

## 10. 향후 계획

### 기능 확장
1. **실시간 알림**
   - WebSocket 기반 실시간 알림
   - 푸시 알림 (FCM)

2. **결제 시스템**
   - PG사 연동
   - 환불 처리
   - 정산 시스템

3. **콘텐츠 관리**
   - 동영상 스트리밍
   - 파일 업로드
   - CDN 연동

### 성능 최적화
1. **캐싱 전략**
   - Redis 캐싱 확대
   - CDN 도입
   - 데이터베이스 쿼리 최적화

2. **확장성 개선**
   - 마이크로서비스 분리
   - 메시지 큐 도입 (SQS/SNS)
   - 서버리스 함수 활용

3. **모니터링 강화**
   - APM 도구 도입
   - 로그 분석 도구
   - 비즈니스 메트릭 대시보드

### 유지보수 방안
1. **자동화**
   - CI/CD 파이프라인 구축
   - 자동 테스트 실행
   - 자동 배포

2. **문서화**
   - API 문서 자동 업데이트
   - 아키텍처 문서 관리
   - 운영 가이드 정리

3. **팀 협업**
   - 코드 리뷰 프로세스
   - 지식 공유 세션
   - 기술 스택 교육

---

**프로젝트 완성도**: 95%
- 핵심 기능 구현 완료
- 동시성 처리 안정성 확보
- 클라우드 배포 환경 구축
- 모니터링 시스템 구축
- 테스트 커버리지 확보

**다음 단계**: 
1. 실시간 알림 시스템 구축
2. 결제 시스템 연동
3. 성능 최적화 및 확장성 개선
